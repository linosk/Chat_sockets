diff --git a/client.py b/client.py
index d168fe3..23e781e 100644
--- a/client.py
+++ b/client.py
@@ -14,27 +14,47 @@ client_socket.connect((ip,port))
 
 stop_condition = threading.Event()
 
+message_recv = ""
+message_send = ""
+
 def receive_message():
     while True:
 
         if stop_condition.is_set():
             break
 
+        global message_send
+        global message_recv
+
         try:
-            message = client_socket.recv(buffer).decode(coding)
-            if message == 'N1CKN4M3':
+            message_recv = client_socket.recv(buffer).decode(coding)
+            if message_recv == 'N1CKN4M3':
                 client_socket.send(nickname.encode(coding))
-            elif message == '':
+            elif message_recv == 'P4SSW0RD':
+                pass
+            #    client_socket.send(password.encode(coding))
+            elif message_recv == 'T3RM1N4T3':
                 client_socket.close()
                 stop_condition.set()
-                print("Connection terminated by the server side.")
+                print("Wrong password, connection terminated.")
+            elif message_recv == '':
+                client_socket.close()
+                stop_condition.set()
+                if not message_send == '/disconnect':
+                    print("Connection terminated by the server side.")
+            elif message_recv == '' and not stop_condition.is_set:
+                client_socket.close()
+                stop_condition.set()
+                if not message_send == '/disconnect':
+                    print("Connection terminated by the server side.")
             else:
-                print(message)
-        #This except does not work
+                print(message_recv)
+
         except:
-            print("Connection terminated by the server side.")
             client_socket.close()
-            break
+            stop_condition.set()
+            if not message_send == '/disconnect':
+                print("Connection terminated by the server side.")
 
 def send_message():
     while True:
@@ -42,24 +62,28 @@ def send_message():
         if stop_condition.is_set():
             break
 
-        message = input("")
-        if message == "":
+        global message_send
+        global message_recv
+
+        if message_recv == 'P4SSW0RD':
+            message_send = input("Password")
+        else:
+            message_send = input("")
+        if message_send == "":
             pass
-        elif message[0] == '/':
-            if message[1:] == 'disconnect':
-                client_socket.send(message.encode(coding))
+        elif message_send[0] == '/':
+            if message_send[1:] == 'disconnect':
+                client_socket.send(message_send.encode(coding))
                 client_socket.close()
                 stop_condition.set()
                 print("You are disconnected from the server.")
+            elif message_send[1:] == 'admin':
+                client_socket.send(message_send.encode(coding))
         else:
-            now = datetime.now()
-            time = now.strftime("%H:%M:%S")
-            client_socket.send(f'[{time}]{nickname}: {message}'.encode(coding))
+            client_socket.send(f'{nickname}: {message_send}'.encode(coding))
 
 receive_thread = threading.Thread(target=receive_message, args=())
 receive_thread.start()
 
 send_thread = threading.Thread(target=send_message, args=())
-send_thread.start()
-
-#client_socket.close()
\ No newline at end of file
+send_thread.start()
\ No newline at end of file
diff --git a/notes.txt b/notes.txt
index 8ef59ea..cc3a1b7 100644
--- a/notes.txt
+++ b/notes.txt
@@ -4,4 +4,26 @@ Issue:
 
 When client A tries to disconnect the actual disconnect does
 not happens until client B sends message.
-When client A is the only one disconnecting does not work.
\ No newline at end of file
+When client A is the only one disconnecting does not work.
+
+Reproduction:
+
+Case 1.
+
+Server start
+Adam connects
+Eve connects
+
+Adam sends /disconnect what happens in adam client and sever?
+
+Still something wrong with disconnect from the client side
+and server side
+
+RESOLVED
+
+Issue:
+
+Time of the message should be added at the server side - RESOLVED
+Function "terminated connection by the server side" does not work - RESOLVED NOT REALLY
+Client should not get information about its own connection/disconnection
+
diff --git a/server.py b/server.py
index 4b4e132..a1f7c71 100644
--- a/server.py
+++ b/server.py
@@ -1,6 +1,6 @@
 import socket
 import threading
-import time
+from datetime import datetime
 
 ip = '127.0.0.1'
 port = 55555
@@ -20,73 +20,74 @@ addresses = []
 #Threads
 threads = []
 
-#Use for sever not for client
-stop_condition = threading.Event()
-
 #Sever broadcasts message to every client
-def broadcast_message(message):
+def broadcast_message(message, type_of_broadcast, new_client):
+    message_decoded = message.decode(coding)
     print(f'Message will be sent to {nicknames}.')
-    for client in clients:
-        client.send(message)
+
+    if type_of_broadcast == 'client_message':
+        for client in clients:
+            now = datetime.now()
+            time = now.strftime("%H:%M:%S")
+            client.send(f'[{time}]{message_decoded}'.encode(coding))
+
+    elif type_of_broadcast == 'connection_info':
+        for client in clients:
+            if not client == new_client:
+                client.send(message)
+    else:
+        pass
 
 def remove_connection_records(index):
-    clients.remove(clients[index])
-    nicknames.remove(nicknames[index])
-    addresses.remove(addresses[index])
-    threads.remove(threads[index])
+    if clients[index] in clients:
+        clients.remove(clients[index])
+        nicknames.remove(nicknames[index])
+        addresses.remove(addresses[index])
+        threads.remove(threads[index])
 
 def handle_client(client):
+    stop_condition = threading.Event()
+    index = clients.index(client)
+    nickname = nicknames[index]
     while True:
 
-        #This cannot be used because every client stops
-        #Unless
         if stop_condition.is_set():
-            stop_condition.clear()
+            print(f'{nickname} disconnected from the server.')
+            broadcast_message(f'{nickname} disconnected from the server.'.encode(coding),'connection_info',client)
             break
 
         try:
             message = client.recv(buffer)
             message_decoded = message.decode(coding)
             if message_decoded[0] == '/':
-                pass
-                #if message_decoded[1:] == 'disconnect':
-                #    client.close()
-                #    index = clients.index(client)
-                #    clients.remove(index)
-                #    nickname = nicknames[index]
-                #    print(nickname)
-                #    nicknames.remove(index)
-                #    addresses.remove(index)
-                #    threads.remove(index)
-                #    broadcast_message(f'{nickname} disconnected from the server.')
-                #    stop_condition.set()
+                if message_decoded[1:] == 'disconnect':
+                    if client in clients:
+                        #Client willingly disconnected
+                        stop_condition.set()
+                        client.close()
+                        remove_connection_records(index)
+                elif message_decoded[1:] == 'admin':
+                    client.send('P4SSW0RD'.encode(coding))
+                    password = client.recv(buffer).decode(coding)
+                    if password == '123':
+                        pass
+                    else:
+                        client.send('T3RM1N4T3'.encode(coding))
+                        if client in clients:
+                            stop_condition.set()
+                            client.close()
+                            remove_connection_records(index)
+
 
             else:
-                broadcast_message(message)
+                broadcast_message(message,'client_message',client)
         except:
-            #condition = False
-            #pass
             
-            stop_condition.set()
-
-            """
-            index = clients.index(client)
-            #print(index)
-            #client.close()
-            print(f'{client} disconnected.')
-            remove_connection_records(index)
-            #broadcast_message(f'{nicknames[index]} disconnected from the server.')
-            condition = True
-            """
-
-            """
-            #break
-            #client.close()
-            #stop_condition.set()
-            #client.send('Connection terminated.')
-            #client.close()
-            #break
-            """
+            #Disconnect from the client side possibly unwillingly
+            if client in clients:
+                stop_condition.set()
+                client.close()
+                remove_connection_records(index)
 
 def server_run():
     while True:
@@ -94,13 +95,14 @@ def server_run():
             client_socket, client_address = server_socket.accept()
             client_socket.send('N1CKN4M3'.encode(coding))
             client_nickname = client_socket.recv(buffer).decode(coding)
+
             print(f'{client_socket} tries to connect from {client_address} and is called {client_nickname}')
 
             clients.append(client_socket)
             nicknames.append(client_nickname)
             addresses.append(client_address)
 
-            broadcast_message(f'{client_nickname} joined the chat.'.encode(coding))
+            broadcast_message(f'{client_nickname} joined the chat.'.encode(coding),'connection_info',client_socket)
             client_socket.send('You are connected to the server.'.encode("utf-8"))
 
             client_thread = threading.Thread(target=handle_client, args=(client_socket,))
@@ -112,4 +114,8 @@ def server_run():
             server_socket.close()
             break
 
-server_run()
\ No newline at end of file
+print("Awaiting connections...")
+
+server_run()
+
+server_socket.close()
\ No newline at end of file
